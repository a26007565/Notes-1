因為過年閒閒沒事，開始來看一點 Go Lang 的書，從官網連結中找到一本『小』書 [The Little Go Book](https://www.openmymind.net/The-Little-Go-Book/)，它是 2014 年發佈的，僅介紹基礎的部分，整份 PDF 只有 84 頁，用來入門的負擔應該不會太大。

另外，可以觀察到這本書的一個特色，作者應該很喜歡七龍珠。一些變數或自訂結構的名稱如：

* Saiyan 賽亞人
* Goku 悟空

所以，才會在第 1 個例子有戰鬥力的數值。

## The Basics (1)

1. 變數宣告
2. 型態推論
3. 函式

第 1 章是介紹基礎知識，除了如何開始跑出第 1 隻 hello world 程式，並開始使用 `import` 來使用 standard library 的功能，還有語法的一些基本常識之外沒有太多難以理解的部分。

### 變數

只是變數宣告或函式宣告的順序跟以外習慣的 Java 或 Python 不太相同。這點可以透過 language specification 中的[語法規則](https://golang.org/ref/spec#Variable_declarations)來說明：

```bnf
VarDecl     = "var" ( VarSpec | "(" { VarSpec ";" } ")" ) .
VarSpec     = IdentifierList ( Type [ "=" ExpressionList ] | "=" ExpressionList ) .
```

能看得出在關鍵字 `var` 後要先接著 `IdentifierList` (簡單說就是一堆變數名稱)，最後才是接到 `Type`，如果有 assignment 的情況，才會再有 `=` 出現。書上的第 1 個宣告變數並開始使用它的範例為：

```go
var power int
power = 9000
```

其實也能寫成同一行，因為 golang 並不允許我們有未使用的變數或其它東西 (例如：import 了卻沒有使用)，它們會是編譯期的錯誤。在這一章，書會也介紹了比較短的宣告型式，並且我們可以省略 `Type` 的部分：

```go
power := 9000
```

同樣地，我們能回到官網找出對應的語法規格：

```bnf
ShortVarDecl = IdentifierList ":=" ExpressionList .
```

由於不再需要寫 `Type` 了，就是透過 golang 自行做型態推論，並且會自動檢查 `:=` 左方的變數 `有新的名字出現`，像我們無法連續寫 2 次的：

```go
power := 9000
power := 5566
```

在寫第 1 組的 `power :=` 前，power 不存在，它是新出現的變數可以宣告。第 2 組的 `:=` 左式，僅有 power 它出現過了，沒有其他新的變數了，編譯會失敗。要讓它合乎語法，我們得加入 `新` 的變數，把上面的例子改寫一下：

```go
power := 9000
power, action := 5566, 8787
```

第 2 組宣告出現了新變數，在語法上就合法了。對已出現過的 power 來說，就是重新賦值的動作而已 (但只能指定一相型態的 int)


### 函式

在第 1 章尾，開始介紹函式如何使用。內容相當簡單，我們截取一下官關的[語法規則](https://golang.org/ref/spec#Function_types)補充：

```bnf
FunctionType   = "func" Signature .
Signature      = Parameters [ Result ] .
Result         = Parameters | Type .
Parameters     = "(" [ ParameterList [ "," ] ] ")" .
ParameterList  = ParameterDecl { "," ParameterDecl } .
ParameterDecl  = [ IdentifierList ] [ "..." ] Type .
```

由上面的規則，可能衍生出下列的例子：

```go
func()
func(x int) int
func(a, _ int, z float32) bool
func(a, b int, z float32) (bool)
func(prefix string, values ...int)
func(a, b int, z float64, opt ...interface{}) (success bool)
func(int, int, float64) (float64, *[]int)
func(n int) func(p *T)
```

比對後可以知道，如同變數宣告一樣，函式的型態也是放在最後，或著可以沒有宣告回傳型態 (因為回傳的 Result 被 `[ ]` 包圍，表示它是 optional 的)：

```
FunctionType   = "func" Signature .
Signature      = Parameters [ Result ] .
```

在書上有提到一個接函式結果時，可以使用 `_` 作為不需要的值的慣例：

```go
_, exists := power("goku")
if exists == false {
// handle this error case
}
```

power 回傳的值為 `(戰鬥力, 是否有此人物)`，它問了 `悟空` 的 power 結果，在這段程式它只在意悟空存不存在，所以使用 `_` 來接目前情境下不重要的戰鬥力。另外做了一個小實驗 `_` 不會被視為 `new variables`，所以使用 `:=` 時不能單獨存在。

## Structures (2)

書上的第 2 部分為結構，並開宗明義表示 Go 並非 OOP 語言，它沒有物件的階層，所以也不會有承繼與多形。它會是一種以 structure 作為資料載體，並將 method 關聯到此結構的實作型式。

```go
type Saiyan struct {
	Name string
	Power int
}
```

結構的第 1 個範例是宣告了『賽亞人』，它有名子，有戰力數值。對寫過 C/C++ 的朋友，對這結構應該不算陌生，雖然語言有點變化，但意義上大致是一樣的。接下來有趣的例子是經驗的將 struct 傳進 function 後，並無法改變原始值的問題：

```go
func Super(s Saiyan) {
	s.Power += 10000
}

func main() {
	goku := Saiyan{
		Name:  "Goku",
		Power: 9000,
	}

	// 悟空要變超級賽亞人囉～～～
	Super(goku)
	fmt.Println(goku)
}
```

輸出結果為

```
{Goku 9000}
```

超了 1 萬點的戰力數值怎麼好意思叫超級賽亞人呢？於是要透過在 C/C++ 已經用到很熟的 `&` 與 `*`，透過傳址與指標來搞定它：

```go
func Super(s *Saiyan) {
	s.Power += 10000
}

func main() {
	goku := &Saiyan{
		Name:  "Goku",
		Power: 9000,
	}

	// 真的變超級賽亞人囉！！！共 19000 的戰力數值
	Super(goku)
	fmt.Println(goku)
}
```

接著，我們還差一點把 function 變得好看一點，實際上我們期望的會是：


```go
goku.Super()
```

而不是

```go
Super(goku)
```

這件事需要稍為改寫一下 Super 函式的宣告，有沒有很像 Python class 在定義 method 時，第 1 個參數要填 self 的感覺：

```go
func (s *Saiyan) Super() {
	s.Power += 10000
}

func main() {
	goku := &Saiyan{
		Name:  "Goku",
		Power: 9000,
	}

	goku.Super()
	fmt.Println(goku)
}
```

在[語法規格](https://golang.org/ref/spec#Method_declarations)上，被提出去的 `(s *Saiyan)` 稱作 Receiver：

```bnf
MethodDecl = "func" Receiver MethodName Signature [ FunctionBody ] .
Receiver   = Parameters .
```

它其實就是 `Parameters`，換句話說，是有變數名稱與 Type 的 list。一旦 function 有了 Receiver，我們就改稱它叫 Method 囉！覺得這詞語慣例其實也挺 OOP 的就是，雖然它沒不支援繼承。 

### 建構子

建構子的概念來自 OOP，即使 golang 不支援我們定義 class，但仍有自訂型態可以用，像 structure 就是一種。所以，慣例上會替 structure 實作 factory method 來建立它：

```go
func NewSaiyan(name string, power int) *Saiyan {
	return &Saiyan{name, power}
}
```

其實就是傳回一個建立好的 Saiyan 結構的位置罷了 (目前的範例不夠大，若建構流程比較多事要做的話，準備 factory method 是合理的選項)。在關於建構子的話題，書上也順便介紹了 `new` 內建函式，它其實是簡化語法用的：


```go
s := &Saiyan{}
s := new(Saiyan)
```

可以直接看 `new` 的定義，僅僅配置好空間，並回傳一個指標：

```go
// The new built-in function allocates memory. The first argument is a type,
// not a value, and the value returned is a pointer to a newly
// allocated zero value of that type.
func new(Type) *Type
```

由於使用 new 函式建立物件，仍要各別指定欄位的內容，跟直接寫在結構內初始參數沒太大差異。本書的作者認為，後者比較被多人接受：

```go
goku := new(Saiyan)
goku.name = "goku"
goku.power = 9001
//vs
goku := &Saiyan {
name: "goku",
power: 9000,
}
```

### 聚合

基於 golang 不支援 class 語法，一些相應用使用方式都會以 structure 為主，例如過去常在 OOP 內把物件嵌入某個物件之內，並透過委派 (delegation) 來間接使用聚合物件的功能。在 golang 裡，要成為聚合 (composition) 只要 `不宣告欄位名稱` 即可：

```go
type Person struct {
	Name string
}

type Saiyan struct {
	*Person
	Power  int
}
```

改寫賽亞人，把名字的部分拆出去到 Person 結構之中，為了讓 Person 在 Saiyan 內是個聚合的型式，我們宣告它的名稱。接下來我們能針對 Person 提供 method

```go
func (p *Person) Introduce() {
	fmt.Printf("Hi, I'm %s\n", p.Name)
}
```

神奇的事發生了，我們能直接對 Saiyan 使用這個 method：

```go
goku.Introduce()
// 會印出 Hi, I'm Goku
```

雖然 Receiver 並非針對 Saiyan，但在 Saiyan 內隱含著有 Person，於是它就會被呼叫到了。